* Process Creation
	* Address Space
		* Child duplicate of parent
		* Child then has a program loaded into it
	* UNIX examples
		* fork() system call creates a new process
			* creates a child process
		* exec() system call used after fork() to replace the
		process' memory space with a new program
			* Starting a whole new program in a process
* fork()
	* fork creates an identical process to the one that called
	fork
		* same program
		* same state including open file descriptors
		* exception: fork returns 0 to the child and a
		positive int to the parent
		* processes are executed in parallel
* execlp()
	* Takes copy of parent and throws it away, replaces it with
	a new program and starts executing that new program
* system()
	* system(char *command);
	* command specifies the executable and arguments in one
	string
		* string would be what you would type into the shell
		like "wc fork_test.c"
	* relative path: looks up the executable in the path
	environment variable
	* first calls fork() then execlp()
	* always returns
		* return value is the exit code from the specified
		command
* Process termination
	* If a parent terminated without invoking wait() the child
	becomes an orphan, orphans become children of init process
	* If parent is executing but not waiting and the child
	process ends, the child process is a zombie
* Cooperating processes
	* Independent processes can't affect or be affected by the
	execution of another process
	* Cooperating process can affect or be affected by the
	execution of another process
		* Allows us to share information and other resources
		like memory
		* Can speed up computations, one processes doing
		different pieces of the computation
		* Pushes towards modular code which makes code much
		simpler and easier to look at/debug
		* convienent
* Multiprocess architecture - chrome browser
	* Many browsers ran as a single process and some still do
		* If one website causes trouble, the entire browser
		crashes
* Producer-consumer problem
	* producer: process generates data through some mechanism
	* consumer: process uses data generated by another
	* Typical approach is to implement a data buffer from 
	producer to consumer
		* unbounded buffer: places to practical limit on the
		size of the buffer
		* bounded buffer: assumes there is a fixed buffer size
		(this one is actually used in practice)
* Circular buffer
	* efficient means of implementing a bounded buffer
	* going to set it up so the producer can efficiently put
	data into the buffer and the consumer can take it out
	without lots of extra copying
	* can sit in shared memory between two processes
	* items are instances of type item
	* two integers keep track of where next item is for reading
	and where the next item is for writing